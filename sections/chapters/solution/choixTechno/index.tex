\section{Choix technologiques}
\label{section:choixTechnologiques}

\subsection*{Choix de l'environnement de programmation}

Parmi la myriade de langages de programmation (avec leurs différentes plateformes logicielles existantes) possibles, nous avons opté pour le langage JavaScript et la plate-forme Node.js pour toutes les parties de notre solution (\Gls{backend}, \Gls{frontend} et \Gls{cli}). \\

Ce langage ne vous est peut-être pas tout à fait inconnu en effet, il est souvent utilisé conjointement avec les interfaces HTML du côté client. Le JavaScript est souvent mal considéré par les utilisateurs, lesquels mettent en cause ses difficultés. \\

Néanmoins, ce langage riche n’en reste pas pour la cause dépourvu d’avantages et pour illustrer ce panel, nous n'en citerons que quelques points : JavaScript est un langage basé sur les événements ; il permet ainsi de mettre à jour dynamiquement l’interface qu’il assiste, et c’est notamment le cas pour la quasi-totalité des fameuses messageries instantanées utilisées partout.\\

Node.js nous permet désormais, à l'instar du PHP, d'écrire du code JavaScript du côté serveur qui servira à répondre aux requêtes du client, tout en bénéficiant des avantages du JavaScript. \\

% width=\textwidth,height=\textheight,keepaspectratio
% height=0.24\textheight semble être la seule solution
% car scale fait n'importe quoi
\begin{figure}[H]
    \includegraphics[width=\textwidth,height=0.24\textheight,keepaspectratio]{images/SchemaNodejs.png}
    \centering
    % Un caption alternative pour ne pas afficher la ref dans la table des figures
    \caption[Du JavaScript aussi bien côté serveur que client]{Du JavaScript aussi bien côté serveur que client~\cite{NodejsIllustrations}}
    \label{pic:WhatIsNodeJs}
\end{figure}

Deux points sont élémentaires pour expliquer l'intérêt et la rapidité de Nodejs : le moteur JavaScript V8 et son fonctionnement non bloquant. \\

Ce moteur, développé par Google, très performant et optimisé propose la compilation à la volée (en anglais, JIT , just-in-time compilation) , approche hybride entre la compilation et l'interprétation, dont nous pouvons schématiser leur mode de fonctionnement individuel par la figure suivante :
\begin{figure}[H]
    \includegraphics[width=\textwidth,height=0.2\textheight,keepaspectratio]{images/compilationVSinterpretation.png}
    \centering
    \caption{Compilation et interprétation - mode de fonctionnement}
\end{figure}

Malheureusement, la compilation et l'interprétation ont chacune leurs qualités et défauts, que l'on peut synthétiser en 4 grands points :
\begin{itemize}
    \item Une fois compilé, on ne peut plus changer le programme (contrairement à l'interprétation)
    \item En cas d'erreur(s) dans le programme, la compilation les affiche dans la phase "compilation" contrairement à l'interprétation qui les affiche à l'exécution. 
    \item La compilation permet d'optimiser les performances d'un programme (car disposant de l'intégralité du code source au départ) mais nécessite un certain temps pour traduire le programme en code machine.
    \item L'interprétation possède moins d'étapes que la compilation.
\end{itemize}

Dans tout système, il existe des tâches coûteuses en temps : des appels à la base de données, etc.
Dans un mode de fonctionnement bloquant, il convient d'attendre la fin de ces taches avant de réaliser autre chose. Ceci est un gâchis dans la mesure où des tâches moins gourmandes en temps sont ainsi bloquées. Node.js permet, par son mode de fonctionnement non bloquant, des gains de performances, comme illustré ci-dessous.

% width=\textwidth,height=\textheight,keepaspectratio
\begin{figure}[H]
    \includegraphics[width=\textwidth,height=0.19\textheight,keepaspectratio]{images/ComparaisonBloquantOuNon.png}
    \centering
    % Un caption alternative pour ne pas afficher la ref dans la table des figures
    \caption[Bloquant/non bloquant : un exemple pour l'illustrer]{Bloquant/non bloquant : un exemple pour l'illustrer~\cite{NodejsIllustrations}}
    \label{pic:BloquantOrNot}
\end{figure}

\pagebreak

\subsection*{Choix des frameworks}

% Sans doute une référence à mettre
De manière générale, un framework peut être considéré comme une boite à outils très pratique nous permettant de développer une application conséquente en disposant de fonctionnalités et d'une structure de base. Nous pouvons citer 2 avantages majeurs à son usage : 
\begin{itemize}
    \item Une architecture spécialement prévue (et souvent éprouvée) pour résoudre des classes de problèmes précises permettant ainsi une maintenabilité / évolutivité  de l'application
    \item Une standardisation de la programmation permettant ainsi d'interchanger, d'injecter et/ou réutiliser du code existant pour ne pas "réinventer la roue".
\end{itemize}
Dès lors, ce choix, qui possède aussi son lot d'inconvénients, ne saurait être pris à la légère, car il constitue le squelette de l'application. C'est pourquoi vous pourrez retrouver ci-dessous une liste non exhaustive des frameworks (dans les tables \ref{table:compFrameworksFrontend}, \ref{table:compFrameworksAPI} et \ref{table:compFrameworksCLI}) que nous avons étudiés ainsi que les critères retenus pour les départager. \\

\noindent\textbf{Critères - [M]auvais, [S]ufficient, [B]on}

\begin{itemize}
    \item[\textbf{Doc}] Documentation : \\
    La présence d'une documentation suffisamment claire et explicite pour répondre aux principales questions sur son utilisation.
    La qualifier n'est pas une tâche aisée, puisque souvent soumise exclusivement à notre subjectivité personnelle : en effet, des mesures quantitatives telles que le ratio entre le nombre de lignes de commentaires (\textbf{CLOC}) et le nombre total de lignes de code (\textbf{LOC}) n'aident pas, car quantité n'est pas synonyme de qualité ... 
    \item[\textbf{Fcts}] Fonctionnalités : \\
    Le nombre de fonctions utilitaires ainsi que de leur degré réciproque d'utilité / de praticité perçu par les utilisateurs. Un choix binaire ne peut dès lors pas s'appliquer : une solution minimaliste en nombre de fonctionnalités pourrait davantage répondre à nos besoins.
    \item[\textbf{Maint}] Maintenabilité d'une application créée avec ce framework : \\
    Il s'agit du degré de facilité avec laquelle la maintenance du code est accomplie. Plusieurs paramètres dont la structure et la complexité du code impactent ce critère. Il s'agit dès lors de ne pas négliger ce critère, car rien n'exclut l'ajout de nouvelles fonctionnalités ou la découverte de bugs à l'avenir.
    \item[\textbf{Pop}] Popularité : \\
    Le fait d'être connu et d'être utilisé par un grand nombre d'utilisateurs.
    Puisque notre solution est entièrement basée sur Node.js, nous pouvons consulter des données publiques du registre par défaut (NPM) notamment par des sites comme \href{https://www.npmtrends.com/}{NPM Trends}.
    \item[\textbf{Perfs}] Performances : \\
    Elles se mesurent en fonction du temps de réponse à une requête client.
    Il convient cependant d'être prudent avec cette explication simpliste : certaines requêtes peuvent nécessiter plus ou moins de ressources.
    De ce fait, les performances d'un framework sont principalement influencées par les technologies utilisées. 
\end{itemize}

Pour calculer le résultat total pour un framework précis, il s'agit de la somme des résultats obtenus pour chacun des critères avec notre système de notation : \textbf{M}, \textbf{S} et \textbf{B} (resp. 0, 0.5 et 1).

\subsubsection*{Framework pour le front-end}
\begin{table}[H]
    \centering
    \begin{threeparttable}
    \begin{tabular}{| l | l | l | l | l | l | l |}
    \hline
        Framework & Doc & Fcts & Maint & Pop & Perfs & Total \\
    \hline
        \href{https://vuejs.org}{Vue.js}\tnote{1} &
        B &  
        B &
        B &            
        S &              
        B &
        4.5 \\
    \hline
        \href{https://angular.io}{Angular}\tnote{2} &
        B &                
        B &   
        B &
        S &              
        B &       
        4.5 \\
    \hline
        \href{https://fr.reactjs.org}{React}\tnote{3} &
        B &                
        B &     
        S &
        B &              
        B &       
        4.5 \\  
    \hline
    \end{tabular}
    \begin{tablenotes}
        \item[1] \url{https://vuejs.org}
        \item[2] \url{https://angular.io}
        \item[3] \url{https://fr.reactjs.org}
    \end{tablenotes}
    \end{threeparttable}
    \caption{Comparatif de quelques frameworks pour le \Gls{frontend}}
    \label{table:compFrameworksFrontend}
\end{table}

Le choix entre ces trois frameworks s'apparente à une décision plus que subjective, car ce sont tous les trois d'excellents outils de développement. \\

Puisqu'il fallait bien trancher, \textit{Vue.js} a été la solution retenue pour la partie front-end car nous l'avions déjà utilisé par le passé. Ce framework est aussi populaire qu'\textit{Angular} mais moins que \textit{React}. Vue détient cependant le plus grand nombre de "\textit{stars}" sur GitHub, ceci traduisant un intérêt non négligeable pour ce framework au sein de la communauté des développeurs.\\

% Temporairement on va changer le style de footnote, pour éviter une confusion
\renewcommand{\thefootnote}{\alph{footnote}}

Au-dessus de \textit{Vue.js}, nous avons utilisé le framework \textit{Nuxt.js}\footnote{\url{https://fr.nuxtjs.org/}} qui permet d'encapsuler la logique des routes, des stores, des plugins et des middlewares de telle manière à ce que le code soit plus facilement maintenable. En outre, il ajoute aussi le mode \textit{SSR} (Server Side Rendering), qui permet à l'application d'être performante, tout en profitant d'un boost pour le référencement naturel (SEO).

% On n'oublie pas de le resetter
\renewcommand{\thefootnote}{\arabic{footnote}}

\subsubsection*{Framework pour l'\Gls{api}}

%\thinspace % 

\begin{table}[H]
    \centering
    \begin{threeparttable}
    \begin{tabular}{| l | l | l | l | l | l | l |}
    \hline
        Framework & Doc & Fcts & Maint & Pop & Perfs & Total \\
    \hline
        \href{https://expressjs.com/}{Express}\tnote{1} &
        B &  
        S &
        S &            
        B &              
        B &
        4 \\
    \hline
        \href{https://loopback.io/}{LoopBack}\tnote{2} &
        B &                
        B &   
        S &
        M &              
        S &      
        3 \\
    \hline
        \href{https://feathersjs.com/}{Feathers}\tnote{3} &
        B &                
        B &     
        S &
        M &              
        S &       
        3 \\  
    \hline
    \end{tabular}
    \begin{tablenotes}
        \item[1] \url{https://expressjs.com/}
        \item[2] \url{https://loopback.io/}
        \item[3] \url{https://feathersjs.com/}
    \end{tablenotes}
    \end{threeparttable}
    \caption{Comparatif de quelques frameworks pour l'\Gls{api}}
    \label{table:compFrameworksAPI}
\end{table}

Express a été la solution que nous avons retenue, car celui-ci offre, bien qu'ayant un nombre de fonctionnalités restreint par rapport à ses concurrents, des possibilités de configuration  adaptées dans le contexte de ce projet. Il est en effet plus aisé d'y incorporer du code écrit par autrui tandis que les autres étudiés se concentrent principalement sur eux-mêmes. 

\subsubsection*{Framework pour le \Gls{cli}}

\begin{table}[H]
    \centering
    \begin{threeparttable}
    \begin{tabular}{| l | l | l | l | l | l | l |}
    \hline
        Framework & Doc & Fcts & Maint & Pop & Perfs & Total \\
    \hline
        \href{http://yargs.js.org/}{Yargs}\tnote{1} &
        B &  
        B &
        B &            
        S &              
        B &   
        4.5 \\
    \hline
        \href{https://github.com/tj/commander.js}{Commander.js}\tnote{2} &
        S &                
        S &   
        M &
        S &              
        S &  
        2 \\
    \hline
        \href{https://github.com/SBoudrias/Inquirer.js}{Inquirer.js}\tnote{3} &
        S &                
        B &     
        S &
        S &              
        S &      
        3 \\  
    \hline
    \end{tabular}
        \begin{tablenotes}
        \item[1] \url{http://yargs.js.org/}
        \item[2] \url{https://github.com/tj/commander.js}
        \item[3] \url{https://github.com/SBoudrias/Inquirer.js}
    \end{tablenotes}
    \end{threeparttable}
    \caption{Comparatif de quelques frameworks pour le \Gls{cli}}
    \label{table:compFrameworksCLI}
\end{table}

Yargs a été la solution que nous avons retenue, car celui-ci surclasse de manière incontestable les autres solutions existantes. En effet, la documentation (très claire et complète) et le nombre de fonctionnalités permettent une rapide adoption pour construire une solution dans les plus brefs délais. 

\subsection*{Choix des \glspl{library} externes}

De nombreuses applications, y compris la nôtre, partagent des besoins communs : de ce fait, il est donc adéquat de réutiliser le travail d'autrui plutôt que de "réinventer la roue". \\

Compte tenu du nombre relativement élevé de \glspl{library} que nous avons utilisées dans les diverses parties de notre solution, nous évoquerons ici uniquement que les plus conséquentes. \\


% Un page break pour l'instant
\subsubsubsection{\Glspl{library} communes}

% Sorry mais les \paragraph ne t'autorisent pas à faire un titre avant
% Une \noindent\underline{} est cependant possible
\underline{\href{https://lodash.com/}{Lodash}}\\

Cette \gls{library} propose un grand nombre de fonctionnalités dont nous allons vous montrer un infime échantillon au moyen de cet exemple :

\lstinputlisting[
    style=ES6,
    caption={Exemple des fonctionnalités de Lodash}
]{codes/lodash.js}

\pagebreak
\subsubsubsection{\Glspl{library} pour le \Gls{frontend}}

\noindent\underline{\href{https://logaretm.github.io/vee-validate/}{VeeValidate}}\\

Un excellent framework, construit pour VueJS, responsable de la validation des différents formulaires présents sur \texttt{SourceCode}. Très facilement, nous pouvons importer des règles de validation (\textit{min} pour minimum de caractères, \textit{max} pour maximum de caractère, \textit{required} pour champs obligatoire, ...) depuis VeeValidate et les ajouter au composant responsable de la validation du champ.\\

Voici un petit exemple d'utilisation tiré du fichier \texttt{login.vue}, responsable d'afficher la page de connexion à un compte :\\

\begin{figure}[H]
    \includegraphics[width=\textwidth,height=0.35\textheight,keepaspectratio]{images/libraries/veevalidate.png}
    \centering
    \caption[VeeValidate : Exemple d'utilisation]{Exemple sur la page login}
\end{figure}

ValidationObserver et ValidationProvider sont deux composants de VeeValidate permettant de gérer un formulaire. Le premier fait office de conteneur, auquel on attache un ou plusieurs ValidationProvider responsables d'un champ en particulier (texte, checkbox, ...). Pour chaque ValidationProvider, il suffit d'ajouter une règle de validation comme c'est le cas pour le champ email : required|email (champ obligatoire et doit être un email).\\

Lorsque l'utilisateur cliquera sur le bouton de connexion, une fonction de validation va être lancée pour dans un premier temps valider le formulaire. Si toutes les règles sont respectées, alors les données sont envoyées à l'API, sinon, un message d'erreur avec l'explication de la règle non respectée s'affichera juste en dessous du champ incorrect.\\

\pagebreak
\noindent\underline{\href{https://tiptap.scrumpy.io}{Tiptap}}\\

Tiptap est un éditeur de texte riche "renderless" (ce terme signifie que la conception du design nous appartient). Cette \gls{library} prévue pour fonctionner avec VueJS permet de mettre en place assez rapidement un éditeur de texte complet et flexible. On peut aisément y rajouter des options comme des triggers que l'on peut attacher à des boutons pour styliser le texte plus facilement. Pour exemple, voici à quoi ressemble l'éditeur de texte de la description d'une \gls{resinfo} :\\

\begin{figure}[H]
    \includegraphics[width=\textwidth,height=0.35\textheight,keepaspectratio]{images/libraries/tiptap.png}
    \centering
    \caption[Tiptap : Exemple d'utilisation]{Exemple d'un éditeur de texte}
\end{figure}

Les boutons en dessous du champ texte permettent de formater le texte (gras, italique, souligné, barré). En cliquant sur un d'eux, le trigger attaché au bouton va lancer une des méthodes appartenant à Tiptap pour modifier le texte et rendre les modifications automatiquement visibles pour l'utilisateur dans l'éditeur de texte.\\

\noindent\underline{\href{https://highlightjs.org}{Highlight.js}}\\

\Gls{library} permettant de détecter automatiquement le langage de programmation dans un texte et de lui appliquer la coloration syntaxique adéquate. Highlight.js est utilisé conjointement avec la libraire Tiptap pour écrire du code dans l'éditeur et profiter de la coloration syntaxique (voir image précédente).\\

\noindent\underline{\href{https://axios.nuxtjs.org/}{Axios}}\\

\Gls{library} facilitant de manière drastique la conception de requêtes HTTP. Nous utilisons donc Axios pour communiquer avec notre API. Voici un exemple d'utilisation : \\

\lstinputlisting[
    style=ES6,
    caption={Axios : Exemple d'utilisation d'une POST request}
]{codes/axios.ts}

Axios contient plusieurs méthodes dont \$post qui est utilisée dans l'exemple. Il suffit de donner en premier argument le endpoint (/api/search) et le payload que l'on veut envoyer en deuxième argument.\\

Chacune de ces méthodes retourne une \href{https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Utiliser_les_promesses}{Promesse} contenant la réponse ou une erreur si la requête ne s'est pas bien exécutée. Une bonne pratique consiste donc à entourer la requête avec un bloc try/catch pour gérer les deux cas.\\

\subsubsubsection{\Glspl{library} pour le \Gls{backend}}

\noindent\underline{\href{https://sequelize.org/master/}{Sequelize}}\\

Afin d'interagir avec la base de données en Postgresql (cf section \ref{sec:ContraintesCdc}), nous avons fait le choix d'utiliser la \gls{library} Sequelize qui propose du mapping objet-relationnel\footnote{
    En anglais, le terme utilisé est \textbf{O}bject-\textbf{R}elational \textbf{M}apping ou \textbf{ORM}.
} (à titre informatif, d'autres alternatives similaires existent, notamment dans Loopback que nous avions étudié en table \ref{table:compFrameworksAPI}).\\

Cette approche, qui s'inscrit dans la lignée de la \textbf{POO}\footnote{
    Programmation orientée objet -
    \href{https://fr.wikipedia.org/wiki/Programmation\_orient\%C3\%A9e\_objet}{https://fr.wikipedia.org/wiki/Programmation\_orientée\_objet}
}, consiste à interagir avec la base de données à travers un logiciel qui s'occupe de faire le lien entre les données stockées et les objets\footnote{
    En \textbf{POO}, le terme "objet" désigne un type abstrait de données, pouvant représenter des choses du monde réel ou non, pouvant contenir un état (c.-à-d. leurs propriétés / caractéristiques) et/ou des comportements (c.-à-d. du code).
} qui les représentent
, nous épargnant ainsi l'usage du \textbf{SQL} (ou un autre langage complexe) et les conversions manuellles de données de chaque côté. 
Nous vons proposons d'ailleurs une illustration récapitulatif en figure \ref{fig:ORMExplanations}.

\begin{figure}[H]
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/libraries/orms-bridge.png}
    \centering
    \caption[Finalité d'un \textbf{ORM}]{Finalité d'un \textbf{ORM}}
    \label{fig:ORMExplanations}
\end{figure}

De ce fait, cela permet de simplifier les interactions\footnote{
    Par exemple, de nombreux \textbf{ORM}s, y compris Sequelize, intègrent la notion de "scopes queries" (\url{https://sequelize.org/master/manual/scopes.html}), permettant de réutiliser du code pour des requêtes fréquemment utilisées.
} entre le \gls{backend} et la base de données, afin de pouvoir changer vers un autre système de gestion de base de données théoriquement sans modifier la logique interne (
quelques restrictions / spécificités / différences techniques peuvent néanmoins se présenter entre le système d'origine et de destination ...
). \\

\noindent\underline{OpenAPI-enforcer}\\

Il s'agit d'une \gls{library} développée et massivement utilisée par la \textbf{BYU}\footnote{
    Brigham Young University - \url{https://www.byu.edu/about}
}. 
Elle permet, sur base de document(s) respectant la \Gls{oas}, d'enrichir notre \Gls{api} de nombreuses fonctionnalités très intéressantes dont voici quelques-unes :

\begin{itemize}[nosep,noitemsep,topsep=0pt,partopsep=0pt,after=\vspace*{2pt}]
    \item Analyse, désérialisation et validation des paramètres de requêtes \textbf{HTTP}.
    \item Mécanisme de réponse automatique en cas d'erreur
    \item Association automatique des chemins au code
\end{itemize}

Nous vous invitons à découvrir la figure \ref{fig:OASEnforcer} qui propose une explication condensée de la \gls{library}.
Nous reviendrons plus en détail sur son intégration dans la section \ref{chapter:api} : cette sous-section ne constituant qu'une brève introduction.
À titre informatif, cette \gls{library} se décline en 3 sous-\glspl{library} :

\begin{itemize}[nosep,noitemsep,topsep=0pt,partopsep=0pt,after=\vspace*{2pt}]
    \item openapi-enforcer\footnote{
        \url{https://github.com/byu-oit/openapi-enforcer}
    } : le cœur de la \gls{library}
    \item openapi-enforcer-middleware\footnote{
        \url{https://github.com/byu-oit/openapi-enforcer-middleware}
    } : le \gls{middleware} de la \gls{library}
    \item openapi-enforcer-multer\footnote{
        \url{https://github.com/byu-oit/openapi-enforcer-multer}
    } : un \gls{middleware} optionnel qui s'occupe automatique de l'upload de fichiers (cf section \ref{section:analyseFonctionnelle})
\end{itemize}

\begin{figure}[H]
    \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/libraries/openapi-enforcer.png}
    \centering
    \caption[Vue globale de la \gls{library} openapi-enforcer]{Vue globale de la \gls{library} openapi-enforcer 
        \footnotemark
    }
    \label{fig:OASEnforcer}
\end{figure}
\footnotetext{
    \url{https://byu-oit.github.io/openapi-enforcer-middleware/getting-started\#setup}
}

\noindent\underline{\href{http://www.passportjs.org/}{Passport.js}}\\

Comme abordé en section \ref{section:analyseFonctionnelle}, une authentification des utilisateurs est requise pour accéder à certaines fonctionnalités.
Il est cependant adéquat de ne pas se limiter, car comme expliqué en section \ref{section:AnalyseNonFonctionnelle} (partie "Sécurité"), l'association d'un nom d'utilisateur et d'un mot de passe ne constitue que l'une des très nombreuses stratégies pour s'authentifier (par exemple via un réseau social).
C'est précisément à cette fin que répond ce \gls{middleware} d'authentification, permettant ainsi l'intégration de stratégies multiples.
En effet, nous avons utilisé dans notre solution 2 stratégies :

\begin{itemize}[nosep,noitemsep,topsep=0pt,partopsep=0pt,after=\vspace*{2pt}]
    \item passport-json\footnote{
        \url{https://github.com/JamesMGreene/passport-json}
    } : pour authentifier l'utilisateur lors de sa première visite
    \item passport-jwt\footnote{
        \url{http://www.passportjs.org/packages/passport-jwt/}
        } : pour implémenter un mécanisme d'authentification \textbf{JWT}\footnote{
            \url{https://jwt.io/}
        }, afin de ne pas redemander à l'utilisateur de se ré-authentifier à chaque requête
\end{itemize}

\noindent\underline{\href{https://github.com/visionmedia/supertest}{Supertest}}\\

\Gls{library} permettant de réaliser des assertions en HTTP de manière plus aisée.
Une de ses particularités est d'être "framework-agnostic", ce qui permet d'utiliser le framework de test de notre choix, dont notamment celui de Facebook : Jest\footnote{
    \url{https://jestjs.io/}
}. (nous reviendrons sur la dimension des tests de manière plus approfondie dans la section \ref{section:codeCoverage})\\

\pagebreak